var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var angular2_1 = require('angular2/angular2');
var modal_1 = require('../modal/modal');
var Commitment_1 = require('../../model/Commitment');
var Home = (function () {
    function Home() {
        this.items = new Array();
        this.items.push(new Commitment_1.Commitment(undefined, undefined));
        this.items.push(new Commitment_1.Commitment(undefined, undefined));
        this.items.push(new Commitment_1.Commitment(undefined, undefined));
        this.items.push(new Commitment_1.Commitment(undefined, undefined));
    }
    Home.prototype.addCommitment = function (commitment) {
        this.items.push(commitment);
        initMaterial();
        return commitment;
    };
    Home.prototype.removeCommitment = function () {
        var confirmRemove = confirm('Remover itens selecionados?');
        if (confirmRemove)
            this.removeSelectedCommitment();
    };
    Home.prototype.removeSelectedCommitment = function () {
        var _this = this;
        var itemsUpdate = new Array();
        this.items.forEach(function (item) {
            if (!_this.selectAll && !item['remove'])
                itemsUpdate.push(item);
        });
        this.items = itemsUpdate;
    };
    Home = __decorate([
        angular2_1.Component({
            selector: 'home',
            template: "\n      <div class=\"home\">\n          <div class=\"button-action\">\n              <button class=\"mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-button--colored\" (click)=\"modal.open();\">\n                  <i class=\"material-icons\">add</i>\n              </button>\n              <button class=\"mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab\" (click)=\"removeCommitment();\">\n                  <i class=\"material-icons\">remove</i>\n              </button>\n          </div>\n          <table class=\"mdl-data-table mdl-shadow--2dp full-width\">\n              <thead>\n                  <tr>\n                      <th>\n                          <label class=\"mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect mdl-data-table__select\" for=\"table-header\">\n                              <input type=\"checkbox\" id=\"table-header\" class=\"mdl-checkbox__input\" [(ng-model)]='selectAll'/>\n                          </label>\n                      </th>\n                      <th class=\"mdl-data-table__cell--non-numeric\">Data</th>\n                      <th>Observa\u00E7\u00E3o</th>\n                  </tr>\n              </thead>\n              <tbody>\n                  <tr *ng-for=\"#item of items #i=index\">\n                      <td>\n                          <label class=\"mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect mdl-data-table__select\">\n                              <input type=\"checkbox\" id=\"row[{{i}}]\" class=\"mdl-checkbox__input\" [(ng-model)]='item.remove'/>\n                          </label>\n                      </td>\n                      <td class=\"mdl-data-table__cell\">{{item.date | date:'dd/MMM/yyyy'}}</td>\n                      <td>{{item.observation}}</td>\n                  </tr>\n              </tbody>\n          </table>\n          <modal #modal (callback)=\"addCommitment($event);\"></modal>\n      </div>\n    ",
            styles: ["\n      .full-width {\n          width:100%;\n      }\n\n      div.home {\n          padding-left: 5%;\n          padding-right: 5%;\n      }\n\n      div.button-action {\n          float:right;\n          margin: 1%;\n      }\n    "],
            directives: [angular2_1.NgFor, modal_1.Modal, angular2_1.FORM_DIRECTIVES]
        }), 
        __metadata('design:paramtypes', [])
    ], Home);
    return Home;
})();
exports.Home = Home;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZyb250ZW5kL2NvbXBvbmVudHMvaG9tZS9ob21lLnRzIl0sIm5hbWVzIjpbIkhvbWUiLCJIb21lLmNvbnN0cnVjdG9yIiwiSG9tZS5hZGRDb21taXRtZW50IiwiSG9tZS5yZW1vdmVDb21taXRtZW50IiwiSG9tZS5yZW1vdmVTZWxlY3RlZENvbW1pdG1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEseUJBQWdELG1CQUFtQixDQUFDLENBQUE7QUFDcEUsc0JBQW9CLGdCQUFnQixDQUFDLENBQUE7QUFDckMsMkJBQXlCLHdCQUF3QixDQUFDLENBQUE7QUFJbEQ7SUE2RElBO1FBQ0lDLElBQUlBLENBQUNBLEtBQUtBLEdBQUdBLElBQUlBLEtBQUtBLEVBQWNBLENBQUNBO1FBQ3JDQSxJQUFJQSxDQUFDQSxLQUFLQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSx1QkFBVUEsQ0FBQ0EsU0FBU0EsRUFBRUEsU0FBU0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDdERBLElBQUlBLENBQUNBLEtBQUtBLENBQUNBLElBQUlBLENBQUNBLElBQUlBLHVCQUFVQSxDQUFDQSxTQUFTQSxFQUFFQSxTQUFTQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUN0REEsSUFBSUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsSUFBSUEsdUJBQVVBLENBQUNBLFNBQVNBLEVBQUVBLFNBQVNBLENBQUNBLENBQUNBLENBQUNBO1FBQ3REQSxJQUFJQSxDQUFDQSxLQUFLQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSx1QkFBVUEsQ0FBQ0EsU0FBU0EsRUFBRUEsU0FBU0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDMURBLENBQUNBO0lBRURELDRCQUFhQSxHQUFiQSxVQUFjQSxVQUF1QkE7UUFDakNFLElBQUlBLENBQUNBLEtBQUtBLENBQUNBLElBQUlBLENBQUNBLFVBQVVBLENBQUNBLENBQUNBO1FBQzVCQSxZQUFZQSxFQUFFQSxDQUFDQTtRQUNmQSxNQUFNQSxDQUFDQSxVQUFVQSxDQUFDQTtJQUN0QkEsQ0FBQ0E7SUFFREYsK0JBQWdCQSxHQUFoQkE7UUFDSUcsSUFBSUEsYUFBYUEsR0FBR0EsT0FBT0EsQ0FBQ0EsNkJBQTZCQSxDQUFDQSxDQUFDQTtRQUMzREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsYUFBYUEsQ0FBQ0E7WUFDZEEsSUFBSUEsQ0FBQ0Esd0JBQXdCQSxFQUFFQSxDQUFDQTtJQUN4Q0EsQ0FBQ0E7SUFFREgsdUNBQXdCQSxHQUF4QkE7UUFBQUksaUJBT0NBO1FBTkdBLElBQUlBLFdBQVdBLEdBQXVCQSxJQUFJQSxLQUFLQSxFQUFjQSxDQUFDQTtRQUM5REEsSUFBSUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsT0FBT0EsQ0FBQ0EsVUFBQUEsSUFBSUE7WUFDbkJBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLEtBQUlBLENBQUNBLFNBQVNBLElBQUlBLENBQUNBLElBQUlBLENBQUNBLFFBQVFBLENBQUNBLENBQUNBO2dCQUNuQ0EsV0FBV0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7UUFDL0JBLENBQUNBLENBQUNBLENBQUNBO1FBQ0hBLElBQUlBLENBQUNBLEtBQUtBLEdBQUdBLFdBQVdBLENBQUNBO0lBQzdCQSxDQUFDQTtJQXhGTEo7UUFBQ0Esb0JBQVNBLENBQUNBO1lBQ1BBLFFBQVFBLEVBQUVBLE1BQU1BO1lBQ2hCQSxRQUFRQSxFQUFFQSx1NERBb0NUQTtZQUNEQSxNQUFNQSxFQUFFQSxDQUFDQSwwT0FjUkEsQ0FBQ0E7WUFDRkEsVUFBVUEsRUFBRUEsQ0FBQ0EsZ0JBQUtBLEVBQUVBLGFBQUtBLEVBQUVBLDBCQUFlQSxDQUFDQTtTQUM5Q0EsQ0FBQ0E7O2FBa0NEQTtJQUFEQSxXQUFDQTtBQUFEQSxDQXpGQSxBQXlGQ0EsSUFBQTtBQWhDWSxZQUFJLE9BZ0NoQixDQUFBIiwiZmlsZSI6ImZyb250ZW5kL2NvbXBvbmVudHMvaG9tZS9ob21lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIE5nRm9yLCBGT1JNX0RJUkVDVElWRVN9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcbmltcG9ydCB7TW9kYWx9IGZyb20gJy4uL21vZGFsL21vZGFsJztcbmltcG9ydCB7Q29tbWl0bWVudH0gZnJvbSAnLi4vLi4vbW9kZWwvQ29tbWl0bWVudCc7XG5cbmRlY2xhcmUgZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCk7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaG9tZScsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJob21lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbi1hY3Rpb25cIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm1kbC1idXR0b24gbWRsLWpzLWJ1dHRvbiBtZGwtYnV0dG9uLS1mYWIgbWRsLWJ1dHRvbi0tbWluaS1mYWIgbWRsLWJ1dHRvbi0tY29sb3JlZFwiIChjbGljayk9XCJtb2RhbC5vcGVuKCk7XCI+XG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+YWRkPC9pPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm1kbC1idXR0b24gbWRsLWpzLWJ1dHRvbiBtZGwtYnV0dG9uLS1mYWIgbWRsLWJ1dHRvbi0tbWluaS1mYWJcIiAoY2xpY2spPVwicmVtb3ZlQ29tbWl0bWVudCgpO1wiPlxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPnJlbW92ZTwvaT5cbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPHRhYmxlIGNsYXNzPVwibWRsLWRhdGEtdGFibGUgbWRsLXNoYWRvdy0tMmRwIGZ1bGwtd2lkdGhcIj5cbiAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgIDx0aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwibWRsLWNoZWNrYm94IG1kbC1qcy1jaGVja2JveCBtZGwtanMtcmlwcGxlLWVmZmVjdCBtZGwtZGF0YS10YWJsZV9fc2VsZWN0XCIgZm9yPVwidGFibGUtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJ0YWJsZS1oZWFkZXJcIiBjbGFzcz1cIm1kbC1jaGVja2JveF9faW5wdXRcIiBbKG5nLW1vZGVsKV09J3NlbGVjdEFsbCcvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwibWRsLWRhdGEtdGFibGVfX2NlbGwtLW5vbi1udW1lcmljXCI+RGF0YTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgPHRoPk9ic2VydmHDp8OjbzwvdGg+XG4gICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICA8dHIgKm5nLWZvcj1cIiNpdGVtIG9mIGl0ZW1zICNpPWluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJtZGwtY2hlY2tib3ggbWRsLWpzLWNoZWNrYm94IG1kbC1qcy1yaXBwbGUtZWZmZWN0IG1kbC1kYXRhLXRhYmxlX19zZWxlY3RcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInJvd1t7e2l9fV1cIiBjbGFzcz1cIm1kbC1jaGVja2JveF9faW5wdXRcIiBbKG5nLW1vZGVsKV09J2l0ZW0ucmVtb3ZlJy8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJtZGwtZGF0YS10YWJsZV9fY2VsbFwiPnt7aXRlbS5kYXRlIHwgZGF0ZTonZGQvTU1NL3l5eXknfX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgIDx0ZD57e2l0ZW0ub2JzZXJ2YXRpb259fTwvdGQ+XG4gICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgPG1vZGFsICNtb2RhbCAoY2FsbGJhY2spPVwiYWRkQ29tbWl0bWVudCgkZXZlbnQpO1wiPjwvbW9kYWw+XG4gICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIHN0eWxlczogW2BcbiAgICAgIC5mdWxsLXdpZHRoIHtcbiAgICAgICAgICB3aWR0aDoxMDAlO1xuICAgICAgfVxuXG4gICAgICBkaXYuaG9tZSB7XG4gICAgICAgICAgcGFkZGluZy1sZWZ0OiA1JTtcbiAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiA1JTtcbiAgICAgIH1cblxuICAgICAgZGl2LmJ1dHRvbi1hY3Rpb24ge1xuICAgICAgICAgIGZsb2F0OnJpZ2h0O1xuICAgICAgICAgIG1hcmdpbjogMSU7XG4gICAgICB9XG4gICAgYF0sXG4gICAgZGlyZWN0aXZlczogW05nRm9yLCBNb2RhbCwgRk9STV9ESVJFQ1RJVkVTXVxufSlcblxuZXhwb3J0IGNsYXNzIEhvbWUge1xuICAgIHByaXZhdGUgaXRlbXMgOiBBcnJheTxDb21taXRtZW50PjtcbiAgICBwcml2YXRlIHNlbGVjdEFsbCA6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheTxDb21taXRtZW50PigpO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IENvbW1pdG1lbnQodW5kZWZpbmVkLCB1bmRlZmluZWQpKTtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBDb21taXRtZW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkKSk7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgQ29tbWl0bWVudCh1bmRlZmluZWQsIHVuZGVmaW5lZCkpO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IENvbW1pdG1lbnQodW5kZWZpbmVkLCB1bmRlZmluZWQpKTtcbiAgICB9XG5cbiAgICBhZGRDb21taXRtZW50KGNvbW1pdG1lbnQgOiBDb21taXRtZW50KSA6IENvbW1pdG1lbnQge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goY29tbWl0bWVudCk7XG4gICAgICAgIGluaXRNYXRlcmlhbCgpO1xuICAgICAgICByZXR1cm4gY29tbWl0bWVudDtcbiAgICB9XG5cbiAgICByZW1vdmVDb21taXRtZW50KCkgOiB2b2lkIHtcbiAgICAgICAgdmFyIGNvbmZpcm1SZW1vdmUgPSBjb25maXJtKCdSZW1vdmVyIGl0ZW5zIHNlbGVjaW9uYWRvcz8nKTtcbiAgICAgICAgaWYgKGNvbmZpcm1SZW1vdmUpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGVkQ29tbWl0bWVudCgpO1xuICAgIH1cblxuICAgIHJlbW92ZVNlbGVjdGVkQ29tbWl0bWVudCgpIDogdm9pZCB7XG4gICAgICAgIHZhciBpdGVtc1VwZGF0ZSA6IEFycmF5PENvbW1pdG1lbnQ+ID0gbmV3IEFycmF5PENvbW1pdG1lbnQ+KCk7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RBbGwgJiYgIWl0ZW1bJ3JlbW92ZSddKVxuICAgICAgICAgICAgICAgIGl0ZW1zVXBkYXRlLnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXNVcGRhdGU7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9